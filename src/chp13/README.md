# 13. 동시성
* 객체는 처리의 추상화, 스레드는 일정의 추상화

## 동시성이 필요한 이유?
* 동시성
  * 무엇과 언제의 결합을 분리하는 전략
* 서블릿 모델 - 웹 어플리케이션이 표존으로 사용하는 동시성 모델
  * 웹 혹인 EJB 컨테이너 아래에서 돌아감
  * 웹 요청이 들어올 때마다 웹 서버는 비동기 식으로 서블릿을 실행
  * 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아감
  * 웹 컨테이너가 제공하는 결합분리 전략은 완벽하지 않음
    * 프로그래머는 동시성을 정확히 구현하도록 각별히 노력을 기울여야 함
* 동시성 채택의 장점
  * 구조정 이점
  * 응답 시간과 작업 처리량 개선

### 미신과 오해
#### 미신과 오해
* 동시성은 항상 성능을 높여 준다.
  * 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나
  * 여러 프로세서가 동시에 처리할 독립적인 계산이 충분이 많은 경우에만 성능이 높아진다.
* 동시성을 구현해도 설계는 변하지 않는다.
  * 단일 스레드 시스템과 다중 스레드 시스템은 설계가 완전 다르다.
* 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  * 실제로 컨테이너가 어떻게 동작하는지
  * 어떻게 동시 수정, 데드락 같은 문제를 피할 수 있는지 알아야 한다.
#### 타당한 생각
* 동시성은 다소 부하를 유발한다.
  * 성능 측면에서 부하가 걸리며 코드도 더 짜야 한다.
* 동시성은 복잡하다.
* 일반적으로, 동시성 버그는 재현하기 힘들다.
* 동시성을 구현하려면, 흔히 근본적인 설계 전략을 재고해야 한다.

## 난관
```java
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
} 
```
* 인스턴스 X를 생성하고, lastIdUsed 필드를 42로 설정한 다음 두 스레드가 해당 인스턴스를 공유
  * 두 스레드 모두 43을 받는 케이스가 생김
* 두 스레드가 getNextId 메서드를 실행하는 잠재적인 경로는 최대 12,870개
  * 대다수 올바른 결과, 일부는 잘못된 결과

## 동시성 방어 원칙
### 단일 책임 원칙
* 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다.
* 권장사항: 동시성 코드는 다른 코드와 분리해야 한다.
* 동시성 구현할 때 고려사항
  * 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  * 동시성 코드는 독자적인 난관이 있다.
  * 잘못 구현한 동시성 코드는, 여러 가지 방식으로 실패한다.
### 따름 정리: 자료 범위를 제한하라
* 권장사항: 자료룰 캡슐화 하고 공유지료를 최대한 줄여라.
* 공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호 해야 함
* 공유자료를 수정하는 위치가 많은 때 발생하는 문제점
  * 보호할 임계영역을 빼먹음
  * 모든 임계영역을 올바로 보호했는지 확인을 여러번 해야 함
  * 버그 찾아 내기가 더더더 힘듬
### 따름 정리: 자료 사본을 사용하라
* 공유 객체를 피하는 법 - 자료 사본을 사용하라.
* 객체를 복사하는 시간과 가비지 컬렉션에 드는 부하 vs 내부 잠금을 없애 절약한 시간
### 따름 정리: 스레드는 가능한 독립적으로 구현하라
* 다른 스레드와 자료를 공유하지 않는다.
* 각 스레드는 클라이언트 요청 하나를 처리한다.
* 권장사항: 독자적인 스레드로, 가능하더면 다른 프로세서에서  돌려도 괜찮도로고 자료를 독립적인 단위로 분할한다.
## 라이브러리를 이해하라
* 자바 5는 동시성 측면에서 많이 안정화 됨
* 스레드 환경에 안전한 컬렉션 사용
* 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용
* 가능하다면 스레드가 차단되지 않는 방법을 사용
* 일부 클래스 라이브러리는 스레드에 안전하지 못함
### 스레드 환경에 안전한 컬렉션
* java.util.concurrent 패키지가 제공하는 클래스
  * ConcurrentHashMap
* 자바5 에 추가된 동시성 관련 클래스
  * ReentrantLack: 한 메서드에서 잠그고, 다른 메서드에서 푸는 락
  * Semaphore: 세마포, 개수가 있는 락
  * CountDownLatch
    * 지정한 수만큼 이벤트가 발생하고 나서야 대기 중인 스레드를 모두 해제하는 락
    * 모든 스레드에게 동시에 공평하게 시작할 기회를 줌
  * 권장사항: 언어가 제공하는 클래스르 ㄹ검토
    * java.util.concurrent
    * java.util.concurrent,atomic
    * java.util.concurrent.locks

## 실행 모델을 이해하라
* 한정된 자원(Bound Resource)
  * 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.
  * ex) 데이터베이스 연결, 길이기 일정한 읽기/쓰기 버퍼
* 상호 배체(Mutual Exclusion)
  * 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우
* 기아(Starvation)
  * 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다리는 것
* 데드락(Deadlock)
  * 여러 스레드가 서로 끝나기를 기다려서 어느 쪽도 진행하지 못하는 상황
* 라이브락(Livelock)
  * 락을 거는 단계에서 각 스레드가 서로를 방해 한다.
  * 프로세스들이 서로 자원을 주거나 받으려는 작업을 반복하지만, 실제로는 아무것도 완성되지 않고 계속해서 상태만 변경
### 생산자-소비자(Producer-Consumer)
* 생산자 스레드
  * 저옵를 생성해 버퍼나 대기열에 넣음
* 소비자 스레드
  * 하나 이상의 스레드가 대기열에서 정보를 가져와 사용
* 대기열
  * 한정된 저원
  * 생산자는 스레드 대기열에 빈 공간이 있어야 정보를 채우고
  * 소비자 스레드는 대기열에 정보가 있어야 가져온다.
  * 대기열을 올바로 사용하려고 생산자 스레드와 소비자 스레드는 서로에게 시그널을 보낸다.
    * 생산자 스레드: 정보를 채운다음 시그널(대기열에 정보가 있다)을 보냄
    * 소비자 스레드: 정보를 읽어들인 후 시그널(대기열에 빈 공간이 있다)을 보냄
### 읽기-쓰기(Readers-Writers)
* 읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높이고, 기아도 방지하는 해법이 필요
* 간단한 전략1 - 읽기 스레드가 없을 때까지 쓰기 스레드가 버퍼를 기다리는 방법
  * 문제점: 일긱 스레드가 계속 이어진다면 쓰기 스레드는 기아 상태에빠짐
* 간단한 전략2 - 쓰기 스레드에게 우선권
  * 문제점: 쓰기 스레드가 계속 이어진다면 처리율 떨어짐
### 식사하는 철학자들(Dining Philosophers)
* 식사하는 철학자들의 예
  * 원형 테이블에 철학자 한무리가 둘러 않음
  * 왼쪽에 각자의 포크, 가운데 스파게티
  * 식사를 할 때 양쪽 포크를 사용해서 먹음
  * 왼쪽 철할자나 오른쪽 철학자가 식사를 하는 상황이라면 기다려야 함
* 철학자 = 스레드, 포크 = 자원
* 권장사항: 위에서 설명한 기본 알고리즘과 각 해법을 이해하라.

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
* 권장사항: 공유 객체 하나에는 동기화 하는 메서드 하나만 사용해라.
* 그럼에도 불구하고, 동기화 하는 여러 메서드가 필요한 경우
  * 클라이언트에서 잠금: 클라이언트에서 첫번째 메서드를 호출하기 이전에 잠그고, 마지막 메서드를 호출할 때까지 잠금을 유지
  * 서버에서 잠금
    * 서버에다"서버를 잠그고 모든 메서드를 호추한 후 잠금을 해제하ㅣ는 메서드"를 구현
    * 클라이언트는 이 메서드 하나를 호출
  * 연결 서버
    * 잠금을 수행하는 중단 단계를 생성
    * 서버에서 잠금과 유사하지만, 원래 서버는 변경하지 않는 방식
## 동기화하는 부분을 작게 만들어라
* 자바에서 synchronized 키워드를 사용하면 락을 설정
  * 락으로 감싼 모든 코드 영역은 한번에 한 스레드만 실행이 가능
* 임계영역: 동시 사용을 막아야만 프로그램이 올바로 동작하는 보호받는 코드 영역
  * 임계영역은 반드시 보호해야 하기 때문에 코드를 짤 때 임계영역의 수를 최대한 줄여야 한다.
  * 거대한 임계영역을 하나로 구현하라는 말이 아님
* 권장사항: 동기화하는 부분을 최대한 작게 만들어라.
## 올바른 종료 코드는 구현하기 어렵다
* 권장사항: 종료 코드를 개발 초기부터 고민하고, 동작하게 초기부터 구현하라.
## 스레드 코드 테스트 하기
* 권장사항: 
  * 문제를 노출하는 테스트 케이스 작성하라.
  * 프로그램 설정과 스스템 설정과 부하를 바꿔가며 자주 돌려라.
  * 테스트가 실패하면 원인을 추적하라.
### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
* 권장사항: 시스템 실패를 일회성이라 치부하지 마라.
### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들지
* 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인하다.
  * 스레드가 호출하는 POJO를 만들어 스레드 환경 밖에서 테스트
* 권장사항
  * 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라.
  * 먼저, 스레드 환경 밖에서 코드를 올바로 돌려라.
### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
* 다중 스레드르 쓰는 코드를 다양한 설정으로 실행해 보기
    * (스레드 수) 한 스레도 실행, 여러 스레드로 실행, 실행 중 스레드 수를 바꿔보기
    * (환경) 스레드 코드를 실제환경인, 테스트 환경에서 도렬보기
    * (속도) 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려 봄
    * 반복 테스트가 가능하도록, 테스트 케이스를 작성
* 권장사항: 다양한 설정에서 실행할 목적으로, 다른 환경에 쉽게 끼워 넣을 수 있게 구현
### 다중 스레드 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
* 적절한 스레드 개수를 파악하는 것은 상당한 시행착오가 필요
* 다양한 설정으로 성능 측정 필요
* 스레드 개수를 조율하기 쉽게 코드 구현
  * 프로그램이 돌아가는 중에 스레드 개수 변경하는 방법도 고려
  * 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 방법도 고려
### 프로세서 수보다 많은 스레드를 돌려보라
* 스와핑: 주 메모리(RAM)가 부족할 때 운영체제는 현재 실행 중인 프로세스의 일부 또는 전체를 디스크에 일시적으로 저장하고, 필요한 다른 프로세스를 주 메모리에 불러옴
* 시스템이 스레드를 스와핑할 때도 문제가 발생하기 때문에 프로세서 수보다 많은 스레드를 돌려 봐야 함
### 다른 플랫폼에서 돌려보라
* 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다.
* 권장사항: 처음부터 그리고 자주 모든 목표 플랫품에서 코드를 돌려라.
### 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
* 드물게 발생하는 오류를 좀 더 자주 일으킬 방법 - 보조 코드 사용
  * Object.wait()
  * Object.sleep()
  * Object.yield()
  * Object.priority()
* 각 메서드는 스레드가 실행되는 순서에 영향을 미친다.
### 직접 구현하기
* 코드에다 직접 wait(), sleep(), yield(), priority() 함수를 추가
```java
public synchronized String nextUrlOrNull() {
    if (hasNext()) {
        String url = urlGenerator.next();
        Thread.yield();
        updateHasNext();
        return url;
    }
    return null;
}
```
### 자동화
* 보조 코드를 자동으로 추가하려면 자동화 도구 사용해야 함
  * AOF(Aspect-Oriented Framework)
  * CGLIB
  * ASM
```java
public class ThreadJigglePoint {
    public static void jiggle() {
    }
}
```
```java
public synchronized String nextUrlOrNull() {
    if (hasNext()) {
        ThreadJigglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJigglePoint.jiggle();
        updateHasNext();
        ThreadJigglePoint.jiggle();
        return url;
    }
    return null;
}
```
* ThreadJigglePoint.jiggle();
  * 무작위로 sleep, yield 등을 호출한다. 때로는 아무작업도 하지 않는다.
* 권장사항: 흔들기 기법을 사용해 오류를 찾아 낸다.
### 결론
* 다중 스레드를 올바르게 구현하려면
1. SRP 준수
   * POJO를 이용해 스레드를 아는 코드와 모르는 코드를 분리
2. 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해
   * 여러 스레드가 공유 자료를 조작하거나 자원풀을 공유
3. 사용하는 라이브러라와 기본 알고리즘을 이해
4. 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해
   * 잠긴 영역에서 다른 잠긴 영역을 호출하지 않는다.
   * 그러려면 공유하는 정보와 공유하지 않는 정보를 제대로 이해 해야 한다.
   * 공유하는 객체 수와 범위를 최대한 줄인다.
   * 클라이언트에거 공유 상태 관리 책임을 넘기지 않는다.
5. 반복해서 테스트
   * 보조크드 추가

